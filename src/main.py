#!/usr/bin/env python3

import logging
import subprocess
import yara
import argparse
import coloredlogs
import requests
import zipfile
from pathlib import Path
import os
import json


password = ""


def handle_input(path, rules):
    """ Checks if the input is a directory, file, or url, and handles it accordingly """
    if is_url(path):     # download from interwebs
        r = requests.get(path)
        if r.status_code == 200:
            save_path = r.url.split("/")[-1]
            logging.debug(save_path)
            with open(save_path, "wb") as f:
                f.write(r.content)
            logging.info("Downloaded sample to " + save_path)
            if is_archive(save_path):
                # logging.debug("is_zipfile " + str(zipfile.is_zipfile(save_path)))
                # logging.debug("exists? " + str(os.path.isfile(save_path)))
                new_path = open_archive(save_path)
                return scan_dir(new_path, rules)
            else:
                return scan_file(save_path, rules)
        else:
            logging.error("Download failed: Error " + str(r.status_code))
    elif "\\" in path or "/" in path:
        # TODO: fix this, this is pretty terrible
        return scan_dir(path, rules)
    elif is_archive(path):
        new_path = open_archive(path)
        return scan_dir(new_path, rules)
    else:
        return scan_file(path, rules)


def is_archive(path: str) -> bool:
    """ Determines if a given filepath is an archive """
    logging.debug("checking if " + path + " is an archive")
    # todo: zipfile.is_zipfile or something
    extension = path.split(".")[-1]
    logging.debug(extension)
    return extension in ["7z", "zip", "rar", "xz"]


def is_url(path: str) -> bool:
    """Checks if a given path is a URL"""
    return "http://" in path or "https://" in path


def dict_to_str(d: dict) -> str:
    """ Turns a dictionary in to a nice string"""
    out = ""
    for k, v in d.items():
        out += str(k, v)
    return out


def compile_rules(dir_source) -> yara.Rules:
    """ Compiles the Yara rules from a directory """
    files = os.listdir(dir_source)
    yara_files = list(filter(lambda x: x.endswith('.yar') or x.endswith('.yara'), files))

    rules_dir = {}

    for rule in yara_files:
        rules_dir[rule] = f'{dir_source}/{rule}'

    rules = yara.compile(filepaths=rules_dir)
    return rules


def open_archive(path: str) -> str:
    """ Opens an archive and returns the extracted location """
    global password
    dest = "/app/extracted"
    logging.info("Opening " + path)
    zip_archive = zipfile.ZipFile(path)
    if password == "":
        zip_archive.extractall(path=dest)
    else:
        zip_archive.extractall(path=dest, pwd=password.encode('utf-8'))  # bytes(password).encode('utf8'))

    return dest


def scan_dir(directory, rules):
    """ Scans a given directory """
    logging.debug("dir " + directory)
    matches = []
    files = os.listdir(directory)
    for file in files:
        matches.append(scan_file(directory + '/' + file, rules))
    return matches


def scan_file(path, rules):
    """ Scans a given file """
    logging.info("Scanning " + path)
    matches = rules.match(path)
    return {'file': path, 'matches': matches}


def format_match(file):
    raw_rules = file['matches']
    rules = []
    for subrule in raw_rules:
        rules.append(subrule.rule)
    file['matches'] = rules


def format_output(matches) -> str:
    """ Nicely formats the output to be printed out """
    if matches is None:
        return "No rule matches"
    logging.info("Results:")

    # Formats by extracting the yaraMatch.rule property for json serialization
    if type(matches) == dict:
        format_match(matches)
    elif type(matches) == list:
        for match in matches:
            format_match(match)
    else:
        logging.debug("Unsupported match format " + type(matches))
        matches = "Unsupported match type. Please see debug log for more details."
    return json.dumps(matches)


def main():
    global password
    coloredlogs.install(level="DEBUG")

    parser = argparse.ArgumentParser(description="Scans a file or folder for malware")
    parser.add_argument("file", metavar="input", type=str, help="the file to scan")  # todo: take in directories
    parser.add_argument("password")
    args = parser.parse_args()
    path = args.file
    password = args.password

    logging.info("Starting malware scanner")
    rules = compile_rules("rules")
    logging.debug("Compiled rules")

    matches = handle_input(path, rules)

    logging.info("Scan complete")

    #logging.info(format_output(matches)) 
    print(format_output(matches)) # Using a print statement so it is sent to stdout


if __name__ == "__main__":
    main()
